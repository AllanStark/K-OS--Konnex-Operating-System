//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR HCS12 C/C++ Compiler V3.11A/W32                 17/Mar/2010  10:33:50 /
// Copyright 1997-2006 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Source file  =  C:\projekte\csProjects\k-os\src\Os_Ctr.c               /
//    Command line =  C:\projekte\csProjects\k-os\src\Os_Ctr.c               /
//                    --preprocess=l C:\projekte\csProjects\k-os\examples\Ex /
//                    01\IAR\Debug\List\ -lC C:\projekte\csProjects\k-os\exa /
//                    mples\Ex01\IAR\Debug\List\ -lB                         /
//                    C:\projekte\csProjects\k-os\examples\Ex01\IAR\Debug\Li /
//                    st\ --code_model=normal --double=32 -o                 /
//                    C:\projekte\csProjects\k-os\examples\Ex01\IAR\Debug\Ob /
//                    j\ --require_prototypes -e -z2 --no_cse --no_unroll    /
//                    --no_inline --no_code_motion --no_tbaa                 /
//                    --no_cross_call --debug "-D_DLIB_CONFIG_FILE=C:\Progra /
//                    mme\IAR Systems\Embedded Workbench Evaluation          /
//                    4.0\HCS12\LIB\DLIB\dlhcs12nfn.h" --segment             /
//                    __data8=DATA8 --segment __data16=DATA16 --segment      /
//                    __banked=BANKED_CODE --segment __non_banked=CODE       /
//                    --segment __intvec=INTVEC --segment __difunct=DIFUNCT  /
//                    --segment __cstack=CSTACK --segment __inittab=INITTAB  /
//                    -I C:\projekte\csProjects\k-os\inc\ -I                 /
//                    C:\projekte\csProjects\common\inc\ -I                  /
//                    C:\projekte\csProjects\common\ -I                      /
//                    C:\projekte\csProjects\common\InstallISR\ -I           /
//                    C:\projekte\csProjects\k-os\examples\Ex01\ -I          /
//                    C:\projekte\csProjects\common\drivers\include\cpu12\   /
//                    -I "C:\Programme\IAR Systems\Embedded Workbench        /
//                    Evaluation 4.0\HCS12\INC\" -I "C:\Programme\IAR        /
//                    Systems\Embedded Workbench Evaluation                  /
//                    4.0\HCS12\INC\DLIB\"                                   /
//    List file    =  C:\projekte\csProjects\k-os\examples\Ex01\IAR\Debug\Li /
//                    st\Os_Ctr.s12                                          /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME Os_Ctr

        RSEG CSTACK:DATA:REORDER:NOROOT(0)

        PUBLIC GetCounterInfo
        PUBLIC GetCounterValue
        PUBLIC GetElapsedCounterValue
        PUBLIC IncrementCounter
        PUBLIC InitCounter
        PUBLIC OsCtr_InitCounters

        EXTERN Os_ServiceContext
        EXTERN __OS_CounterDefs
        EXTERN Os_CounterValues
        EXTERN OsCallevel
        EXTERN OsFlags
        EXTERN OsCurrentTCB
        EXTERN OS_AlarmValue
        EXTERN OSSaveServiceContext
        EXTERN OsAlm_GetActiveAlarms
        EXTERN OsAlm_NotifyAlarm
        EXTERN OsErrorCallErrorHook
        EXTERN ResumeAllInterrupts
        EXTERN ResumeOSInterrupts
        EXTERN SuspendAllInterrupts
        EXTERN SuspendOSInterrupts
        EXTERN Utl_IsNull

// C:\projekte\csProjects\k-os\src\Os_Ctr.c
//    1 /*
//    2  * k_os (Konnex Operating-System based on the OSEK/VDX-Standard).
//    3  *
//    4  * (C) 2007-2009 by Christoph Schueler <chris@konnex-tools.de>
//    5  *
//    6  * All Rights Reserved
//    7  *
//    8  * This program is free software; you can redistribute it and/or modify
//    9  * it under the terms of the GNU General Public License as published by
//   10  * the Free Software Foundation; either version 2 of the License, or
//   11  * (at your option) any later version.
//   12  *
//   13  * This program is distributed in the hope that it will be useful,
//   14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
//   15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   16  * GNU General Public License for more details.
//   17  *
//   18  * You should have received a copy of the GNU General Public License along
//   19  * with this program; if not, write to the Free Software Foundation, Inc.,
//   20  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
//   21  *
//   22  */
//   23 
//   24 #include "Osek.h"
//   25 
//   26 
//   27 static void OsCtr_UpdateAttachedAlarms(CounterType CounterID);
//   28 static void OsCtr_UpdateAttachedScheduleTables(CounterType CounterID);
//   29 
//   30 

        RSEG CODE:CODE:NOROOT(0)
//   31 StatusType InitCounter(CounterType CounterID,TickType InitialValue)
InitCounter:
//   32 {
        PSHX
        PSHA
        STAB    0x0,SP
        TFR     Y,X
//   33 /*
//   34 	Standard-Status:
//   35 		– E_OK – no error.
//   36 	Extended-Status:
//   37 		– E_OS_ID – the counter identifier is invalid.
//   38 		– E_OS_VALUE – the counter initialization value exceeds
//   39 		  the maximum admissible value.
//   40 		– E_OS_CALLEVEL – a call at interrupt level (not allowed).
//   41 */
//   42    /* todo: Callout-Funktion, um den Initialisierungs-Parameter abzufragen ... dann wird 'InitialValue' nicht benötigt!!! */
//   43 
//   44     SAVE_SERVICE_CONTEXT(OSServiceId_InitCounter,CounterID,InitialValue,NULL);
        LDD     #0x0
        PSHD
        LDAB    #0x5a
        PSHB
        TFR     X,D
        PSHD
        LDAB    0x5,SP
        EXG     B,Y
        PULD
        JSR     OSSaveServiceContext
//   45     ASSERT_VALID_COUNTERID(CounterID);
        LDAB    0x3,SP
        CMPB    #0x1
        LEAS    0x3,SP
        BCS     ??InitCounter_0
        LDAB    #0x3
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x3
        BRA     ??InitCounter_1
//   46     ASSERT_VALID_COUNTER_VALUE(CounterID,InitialValue);
??InitCounter_0:
        LDAB    0x0,SP
        LDAA    #0xb
        MUL
        TFR     D,Y
        CPX     __OS_CounterDefs + 2,Y
        BLS     ??InitCounter_2
        LDAB    #0x8
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x8
        BRA     ??InitCounter_1
//   47 #if 0
//   48     ASSERT_VALID_CALLEVEL(CL_TASK|CL_ISR2);
//   49 #endif
//   50 
//   51     DISABLE_ALL_OS_INTERRUPTS();
??InitCounter_2:
        JSR     SuspendOSInterrupts
//   52     Os_CounterValues[CounterID]=InitialValue;
        LDAA    0x0,SP
        LDAB    #0x2
        MUL
        TFR     D,Y
        STX     Os_CounterValues,Y
//   53     ENABLE_ALL_OS_INTERRUPTS();
        JSR     ResumeOSInterrupts
//   54 
//   55     CLEAR_SERVICE_CONTEXT();
        CLR     Os_ServiceContext
//   56     return E_OK;
        LDAB    #0x0
??InitCounter_1:
        PULA
        PULX
        RTS
//   57 }
//   58 
//   59 

        RSEG CODE:CODE:NOROOT(0)
//   60 StatusType IncrementCounter(CounterType CounterID)
IncrementCounter:
//   61 {
        PSHX
        PSHA
        STAB    0x0,SP
//   62 /*
//   63 **	Standard-Status:
//   64 **		– E_OK – no error.
//   65 **	Extended-Status:
//   66 **		– E_OS_ID – the counter identifier is invalid or
//   67 **		  belongs to hardware counter.
//   68 */
//   69 
//   70 /*  CtrInfoRefType counter; */
//   71 
//   72 /*	"The CounterID was not valid or Counter is implemented in Hardware  */
//   73 /*	and cannot be incremented in Software". */
//   74     SAVE_SERVICE_CONTEXT(OSServiceId_IncrementCounter,CounterID,NULL,NULL);
        LDD     #0x0
        PSHD
        LDAB    #0x5c
        PSHB
        LDD     #0x0
        PSHD
        LDAB    0x5,SP
        EXG     B,Y
        PULD
        JSR     OSSaveServiceContext
//   75     ASSERT_VALID_COUNTERID(CounterID);
        LDAB    0x3,SP
        CMPB    #0x1
        LEAS    0x3,SP
        BCS     ??IncrementCounter_2
        LDAB    #0x3
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x3
        BRA     ??IncrementCounter_3
//   76     ASSERT_VALID_CALLEVEL(OS_CL_TASK|OS_CL_ISR2);
??IncrementCounter_2:
        BRCLR   OsCallevel + 1,#0x3,??IncrementCounter_0
        BRA     ??IncrementCounter_4
??IncrementCounter_0:
        LDAB    #0x2
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x2
        BRA     ??IncrementCounter_3
//   77 
//   78     SuspendAllInterrupts();   /*    DISABLE_ALL_OS_INTERRUPTS();         */
??IncrementCounter_4:
        JSR     SuspendAllInterrupts
//   79 
//   80     Os_CounterValues[CounterID]=(Os_CounterValues[CounterID]+(TickType)1) % __OS_CounterDefs[CounterID].CounterParams.maxallowedvalue;
        LDAB    0x0,SP
        LDAA    #0x2
        MUL
        TFR     D,Y
        LDD     Os_CounterValues,Y
        ADDD    #0x1
        PSHD
        LDAA    0x2,SP
        LDAB    #0xb
        MUL
        TFR     D,Y
        LDX     __OS_CounterDefs + 2,Y
        PULD
        IDIV
        PSHD
        LDAA    0x2,SP
        LDAB    #0x2
        MUL
        TFR     D,X
        PULY
        STY     Os_CounterValues,X
//   81 
//   82     ResumeAllInterrupts();    /* ENABLE_ALL_OS_INTERRUPTS(); */
        JSR     ResumeAllInterrupts
//   83 
//   84 #if defined(OS_USE_ALARMS)
//   85     OsCtr_UpdateAttachedAlarms(CounterID);
        LDAB    0x0,SP
        JSR     OsCtr_UpdateAttachedAlarms
//   86 #endif
//   87 
//   88 #if defined(OS_USE_SCHEDULE_TABLES)
//   89     OsCtr_UpdateAttachedScheduleTables(CounterID);
        LDAB    0x0,SP
        JSR     OsCtr_UpdateAttachedScheduleTables
//   90 #endif
//   91 
//   92     OS_COND_SCHEDULE_FROM_TASK_LEVEL();
        BRCLR   OsFlags,#0x2,??IncrementCounter_1
        BRA     ??IncrementCounter_5
??IncrementCounter_1:
        LDY     OsCurrentTCB
        LDAB    0x6,Y
        INCB
        BEQ     ??IncrementCounter_5
        SWI
//   93 
//   94     CLEAR_SERVICE_CONTEXT();
??IncrementCounter_5:
        CLR     Os_ServiceContext
//   95     return E_OK;
        LDAB    #0x0
??IncrementCounter_3:
        PULA
        PULX
        RTS
//   96 }
//   97 
//   98 

        RSEG CODE:CODE:NOROOT(0)
//   99 StatusType GetCounterInfo(CounterType CounterID,CtrInfoRefType Info)
GetCounterInfo:
//  100 {
        PSHX
        LEAS    -0x3,SP
        STAB    0x0,SP
        STY     0x1,SP
//  101 /*	Standard-Status:
//  102 **		– E_OK – no error.
//  103 **	Extended-Status:
//  104 **		– E_OS_ID – the counter identifier is invalid.
//  105 */
//  106     SAVE_SERVICE_CONTEXT(OSServiceId_GetCounterInfo,CounterID,/*Info*/NULL,NULL);
        LDD     #0x0
        PSHD
        LDAB    #0x5e
        PSHB
        LDD     #0x0
        PSHD
        LDAB    0x5,SP
        EXG     B,Y
        PULD
        JSR     OSSaveServiceContext
//  107     ASSERT_VALID_COUNTERID(CounterID);
        LDAB    0x3,SP
        CMPB    #0x1
        LEAS    0x3,SP
        BCS     ??GetCounterInfo_1
        LDAB    #0x3
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x3
        BRA     ??GetCounterInfo_2
//  108     ASSERT_VALID_CALLEVEL(OS_CL_TASK|OS_CL_ISR2);
??GetCounterInfo_1:
        BRCLR   OsCallevel + 1,#0x3,??GetCounterInfo_0
        BRA     ??GetCounterInfo_3
??GetCounterInfo_0:
        LDAB    #0x2
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x2
        BRA     ??GetCounterInfo_2
//  109 
//  110     *Info=__OS_CounterDefs[CounterID].CounterParams;
??GetCounterInfo_3:
        LDX     0x1,SP
        LDAB    0x0,SP
        LDAA    #0xb
        MUL
        ADDD    #__OS_CounterDefs + 2
        TFR     D,Y
        MOVW    2,Y+,2,X+
        MOVW    2,Y+,2,X+
        MOVW    0x0,Y,0x0,X
//  111 
//  112     CLEAR_SERVICE_CONTEXT();
        CLR     Os_ServiceContext
//  113     return E_OK;
        LDAB    #0x0
??GetCounterInfo_2:
        LEAS    0x3,SP
        PULX
        RTS
//  114 }
//  115 
//  116 

        RSEG CODE:CODE:NOROOT(0)
//  117 StatusType GetCounterValue(CounterType CounterID,TickRefType Value)
GetCounterValue:
//  118 {
        PSHX
        PSHA
        STAB    0x0,SP
        TFR     Y,X
//  119 /*
//  120 **	Standard-Status:
//  121 **		– E_OK – no error.
//  122 **	Extended-Status:
//  123 **		– E_OS_ID – the counter identifier is invalid.
//  124 */
//  125     SAVE_SERVICE_CONTEXT(OSServiceId_GetCounterValue,CounterID,/*Value*/NULL,NULL);
        LDD     #0x0
        PSHD
        LDAB    #0x60
        PSHB
        LDD     #0x0
        PSHD
        LDAB    0x5,SP
        EXG     B,Y
        PULD
        JSR     OSSaveServiceContext
//  126     ASSERT_VALID_COUNTERID(CounterID);
        LDAB    0x3,SP
        CMPB    #0x1
        LEAS    0x3,SP
        BCS     ??GetCounterValue_1
        LDAB    #0x3
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x3
        BRA     ??GetCounterValue_2
//  127     ASSERT_VALID_CALLEVEL(OS_CL_TASK|OS_CL_ISR2);
??GetCounterValue_1:
        BRCLR   OsCallevel + 1,#0x3,??GetCounterValue_0
        BRA     ??GetCounterValue_3
??GetCounterValue_0:
        LDAB    #0x2
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x2
        BRA     ??GetCounterValue_2
//  128 
//  129     DISABLE_ALL_OS_INTERRUPTS();
??GetCounterValue_3:
        JSR     SuspendOSInterrupts
//  130     *Value=Os_CounterValues[CounterID];
        LDAB    0x0,SP
        LDAA    #0x2
        MUL
        TFR     D,Y
        LDD     Os_CounterValues,Y
        STD     0x0,X
//  131     ENABLE_ALL_OS_INTERRUPTS();
        JSR     ResumeOSInterrupts
//  132 
//  133     CLEAR_SERVICE_CONTEXT();
        CLR     Os_ServiceContext
//  134     return E_OK;
        LDAB    #0x0
??GetCounterValue_2:
        PULA
        PULX
        RTS
//  135 }
//  136 
//  137 

        RSEG CODE:CODE:NOROOT(0)
//  138 StatusType GetElapsedCounterValue(CounterType CounterID,TickRefType Value,TickRefType ElapsedValue)
GetElapsedCounterValue:
//  139 {
        PSHX
        PSHD
        STD     0x0,SP
        TFR     Y,X
//  140     SAVE_SERVICE_CONTEXT(OSServiceId_GetElapsedCounterValue,CounterID,Value,/*ElapsedValue*/NULL);
        LDD     #0x0
        PSHD
        LDAB    #0x62
        PSHB
        TFR     X,D
        PSHD
        LDAB    0xb,SP
        EXG     B,Y
        PULD
        JSR     OSSaveServiceContext
//  141     ASSERT_VALID_COUNTERID(CounterID);
        LDAB    0x9,SP
        CMPB    #0x1
        LEAS    0x3,SP
        BCS     ??GetElapsedCounterValue_1
        LDAB    #0x3
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x3
        BRA     ??GetElapsedCounterValue_2
//  142     ASSERT_VALID_CALLEVEL(OS_CL_TASK|OS_CL_ISR2);
??GetElapsedCounterValue_1:
        BRCLR   OsCallevel + 1,#0x3,??GetElapsedCounterValue_0
        BRA     ??GetElapsedCounterValue_3
??GetElapsedCounterValue_0:
        LDAB    #0x2
        JSR     OsErrorCallErrorHook
        CLR     Os_ServiceContext
        LDAB    #0x2
        BRA     ??GetElapsedCounterValue_2
//  143     ASSERT_IS_NOT_NULL(Value);
??GetElapsedCounterValue_3:
        TFR     X,Y
        JSR     Utl_IsNull
        CMPB    #0x0
        BEQ     ??GetElapsedCounterValue_4
        bgnd
//  144 
//  145     DISABLE_ALL_OS_INTERRUPTS();
??GetElapsedCounterValue_4:
        JSR     SuspendOSInterrupts
//  146     if (Os_CounterValues[CounterID]<(*Value)) {
        LDAB    0x6,SP
        LDAA    #0x2
        MUL
        TFR     D,Y
        LDD     Os_CounterValues,Y
        CPD     0x0,X
        BCC     ??GetElapsedCounterValue_5
//  147         *ElapsedValue=__OS_CounterDefs[CounterID].CounterParams.maxallowedvalue-
//  148             (*Value)-Os_CounterValues[CounterID]+(TickType)1;
        LDAB    0x6,SP
        LDAA    #0x2
        MUL
        TFR     D,Y
        PSHY
        LDAB    0x8,SP
        LDAA    #0xb
        MUL
        TFR     D,Y
        LDD     __OS_CounterDefs + 2,Y
        SUBD    0x0,X
        PULY
        SUBD    Os_CounterValues,Y
        ADDD    #0x1
        STD     [0x0,SP]
        BRA     ??GetElapsedCounterValue_6
//  149     } else {
//  150         *ElapsedValue=Os_CounterValues[CounterID]-(*Value);
??GetElapsedCounterValue_5:
        LDAB    0x6,SP
        LDAA    #0x2
        MUL
        TFR     D,Y
        LDD     Os_CounterValues,Y
        SUBD    0x0,X
        STD     [0x0,SP]
//  151     }
//  152     ENABLE_ALL_OS_INTERRUPTS();
??GetElapsedCounterValue_6:
        JSR     ResumeOSInterrupts
//  153 
//  154     CLEAR_SERVICE_CONTEXT();
        CLR     Os_ServiceContext
//  155     return E_OK;
        LDAB    #0x0
??GetElapsedCounterValue_2:
        PULY
        PULX
        RTS
//  156 }
//  157 
//  158 

        RSEG CODE:CODE:NOROOT(0)
//  159 void OsCtr_InitCounters(void)
OsCtr_InitCounters:
//  160 {
        PSHA
//  161     CounterType i;
//  162 
//  163     for (i=(CounterType)0;i<OS_NUMBER_OF_COUNTERS;++i) {
        CLR     0x0,SP
??OsCtr_InitCounters_0:
        LDAB    0x0,SP
        CMPB    #0x1
        BCC     ??OsCtr_InitCounters_1
//  164         (void)InitCounter(i,(TickType)0);
        LDY     #0x0
        LDAB    0x0,SP
        JSR     InitCounter
//  165     }
        LDAB    0x0,SP
        ADDB    #0x1
        STAB    0x0,SP
        BRA     ??OsCtr_InitCounters_0
//  166 }
??OsCtr_InitCounters_1:
        PULA
        RTS
//  167 
//  168 

        RSEG CODE:CODE:NOROOT(0)
//  169 static void OsCtr_UpdateAttachedAlarms(CounterType CounterID)
OsCtr_UpdateAttachedAlarms:
//  170 {
        PSHX
        LEAS    -0x5,SP
        STAB    0x4,SP
//  171     uint8_least idx=(uint8_least)0x00;
        CLR     0x0,SP
//  172     /*Os_AlarmStateType*/uint16 Alarms=OsAlm_GetActiveAlarms();
        JSR     OsAlm_GetActiveAlarms
        STD     0x2,SP
//  173     AlarmType AlarmID;
//  174 
//  175     while (Alarms!=(uint8)0x00) {
??OsCtr_UpdateAttachedAlarms_1:
        LDD     0x2,SP
        BEQ     ??OsCtr_UpdateAttachedAlarms_2
//  176         if ((Alarms & BIT0)==BIT0) {
        BRCLR   0x3,SP,#0x1,??OsCtr_UpdateAttachedAlarms_0
//  177             AlarmID=__OS_CounterDefs[CounterID].AlarmsForCounter[idx];
        LDAB    0x4,SP
        LDAA    #0xb
        MUL
        TFR     D,Y
        LDY     __OS_CounterDefs + 9,Y
        LDAB    0x0,SP
        LEAY    B,Y
        LDAB    0x0,Y
        STAB    0x1,SP
//  178             if (--OS_AlarmValue[AlarmID].ExpireCounter==(uint16)0) {
        LDAB    0x1,SP
        LDAA    #0x4
        MUL
        TFR     D,Y
        LDY     OS_AlarmValue,Y
        LEAY    -0x1,Y
        LDAA    0x1,SP
        LDAB    #0x4
        MUL
        TFR     D,X
        STY     OS_AlarmValue,X
        CPY     #0x0
        BNE     ??OsCtr_UpdateAttachedAlarms_0
//  179                 OsAlm_NotifyAlarm(AlarmID);
        LDAB    0x1,SP
        JSR     OsAlm_NotifyAlarm
//  180             }
//  181         }
//  182         Alarms>>=1;
??OsCtr_UpdateAttachedAlarms_0:
        LDD     0x2,SP
        LSRD
        STD     0x2,SP
//  183         idx++;
        LDAB    0x0,SP
        ADDB    #0x1
        STAB    0x0,SP
        BRA     ??OsCtr_UpdateAttachedAlarms_1
//  184     }
//  185 }
??OsCtr_UpdateAttachedAlarms_2:
        LEAS    0x5,SP
        PULX
        RTS
//  186 
//  187 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  188 static void OsCtr_UpdateAttachedScheduleTables(CounterType CounterID)
OsCtr_UpdateAttachedScheduleTables:
//  189 {
//  190 }
        RTS

        END
// 
// 699 bytes in segment CODE
// 
// 699 bytes of CODE memory
//
//Errors: none
//Warnings: 1
