//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR HCS12 C/C++ Compiler V3.11A/W32                 17/Mar/2010  10:33:42 /
// Copyright 1997-2006 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Source file  =  C:\projekte\csProjects\common\src\Utl.c                /
//    Command line =  C:\projekte\csProjects\common\src\Utl.c                /
//                    --preprocess=l C:\projekte\csProjects\k-os\examples\Ex /
//                    01\IAR\Debug\List\ -lC C:\projekte\csProjects\k-os\exa /
//                    mples\Ex01\IAR\Debug\List\ -lB                         /
//                    C:\projekte\csProjects\k-os\examples\Ex01\IAR\Debug\Li /
//                    st\ --code_model=normal --double=32 -o                 /
//                    C:\projekte\csProjects\k-os\examples\Ex01\IAR\Debug\Ob /
//                    j\ --require_prototypes -e -z2 --no_cse --no_unroll    /
//                    --no_inline --no_code_motion --no_tbaa                 /
//                    --no_cross_call --debug "-D_DLIB_CONFIG_FILE=C:\Progra /
//                    mme\IAR Systems\Embedded Workbench Evaluation          /
//                    4.0\HCS12\LIB\DLIB\dlhcs12nfn.h" --segment             /
//                    __data8=DATA8 --segment __data16=DATA16 --segment      /
//                    __banked=BANKED_CODE --segment __non_banked=CODE       /
//                    --segment __intvec=INTVEC --segment __difunct=DIFUNCT  /
//                    --segment __cstack=CSTACK --segment __inittab=INITTAB  /
//                    -I C:\projekte\csProjects\k-os\inc\ -I                 /
//                    C:\projekte\csProjects\common\inc\ -I                  /
//                    C:\projekte\csProjects\common\ -I                      /
//                    C:\projekte\csProjects\common\InstallISR\ -I           /
//                    C:\projekte\csProjects\k-os\examples\Ex01\ -I          /
//                    C:\projekte\csProjects\common\drivers\include\cpu12\   /
//                    -I "C:\Programme\IAR Systems\Embedded Workbench        /
//                    Evaluation 4.0\HCS12\INC\" -I "C:\Programme\IAR        /
//                    Systems\Embedded Workbench Evaluation                  /
//                    4.0\HCS12\INC\DLIB\"                                   /
//    List file    =  C:\projekte\csProjects\k-os\examples\Ex01\IAR\Debug\Li /
//                    st\Utl.s12                                             /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME Utl

        RSEG CSTACK:DATA:REORDER:NOROOT(0)

        EXTERN ??lmul
        EXTERN ??lumod
        EXTERN ??ludiv
        EXTERN ??lior
        EXTERN ?cstart_init_copy

        PUBWEAK `?*?DATA16_ID`
        PUBWEAK ?init?tab?DATA16_I
        PUBLIC Utl_BinSearch
        PUBLIC Utl_BitGet
        PUBLIC Utl_BitGetHighest
        PUBLIC Utl_BitGetLowest
        PUBLIC Utl_BitReset
        PUBLIC Utl_BitResetLowest
        PUBLIC Utl_BitSet
        PUBLIC Utl_BitSetLowest
        PUBLIC Utl_BitToggle
        PUBLIC Utl_CheckEndianess
        PUBLIC Utl_FloatsAreNearlyEqual
        PUBLIC Utl_IsNull
        PUBLIC Utl_Itoa
        PUBLIC Utl_Log2
        PUBLIC Utl_MemCopy
        PUBLIC Utl_MemSet
        PUBLIC Utl_Random
        PUBLIC Utl_Randomize
        PUBLIC Utl_StrCat
        PUBLIC Utl_StrChr
        PUBLIC Utl_StrCpy
        PUBLIC Utl_StrLen
        PUBLIC Utl_StrRev
        PUBLIC Utl_Swap16
        PUBLIC Utl_Swap32

// C:\projekte\csProjects\common\src\Utl.c
//    1 /*
//    2  * k_os (Konnex Operating-System based on the OSEK/VDX-Standard).
//    3  *
//    4  * (C) 2007-2009 by Christoph Schueler <chris@konnex-tools.de>
//    5  *
//    6  * All Rights Reserved
//    7  *
//    8  * This program is free software; you can redistribute it and/or modify
//    9  * it under the terms of the GNU General Public License as published by
//   10  * the Free Software Foundation; either version 2 of the License, or
//   11  * (at your option) any later version.
//   12  *
//   13  * This program is distributed in the hope that it will be useful,
//   14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
//   15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   16  * GNU General Public License for more details.
//   17  *
//   18  * You should have received a copy of the GNU General Public License along
//   19  * with this program; if not, write to the Free Software Foundation, Inc.,
//   20  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
//   21  *
//   22  */
//   23  #include "Utl.h"
//   24 

        RSEG DATA16_I:DATA:NOROOT(0)
        REQUIRE ?cstart_init_copy
//   25 static uint32 NextRandomNumber=1;
NextRandomNumber:
        DS8 4
        REQUIRE `?<Initializer for NextRandomNumber>`
//   26 

        RSEG DATA16_C:CONST:REORDER:NOROOT(0)
//   27 static const uint16 PowerOfTwoTab16[16]={
PowerOfTwoTab16:
        DC16 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192
        DC16 16384, 32768
//   28     (uint16)0x0001U,(uint16)0x0002U,(uint16)0x0004U,(uint16)0x0008U,
//   29     (uint16)0x0010U,(uint16)0x0020U,(uint16)0x0040U,(uint16)0x0080U,
//   30     (uint16)0x0100U,(uint16)0x0200U,(uint16)0x0400U,(uint16)0x0800U,
//   31     (uint16)0x1000U,(uint16)0x2000U,(uint16)0x4000U,(uint16)0x8000U
//   32 };
//   33 
//   34 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//   35 boolean Utl_BitGet(uint16 w,uint8 num)
Utl_BitGet:
//   36 {
        PSHA
        STAB    0x0,SP
//   37     return ((w & PowerOfTwoTab16[num])!=(uint16)0x0000U);
        TFR     Y,D
        PSHD
        LDAA    0x2,SP
        LDAB    #0x2
        MUL
        TFR     D,Y
        PULD
        BITB    PowerOfTwoTab16 + 1,Y
        BNE     ??Utl_BitGet_0
        BITA    PowerOfTwoTab16,Y
        BEQ     ??Utl_BitGet_1
??Utl_BitGet_0:
        LDAB    #0x1
        BRA     ??Utl_BitGet_2
??Utl_BitGet_1:
        LDAB    #0x0
??Utl_BitGet_2:
        PULA
        RTS
//   38 }
//   39 
//   40 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//   41 uint16 Utl_BitSet(uint16 w,uint8 num)
Utl_BitSet:
//   42 {
        PSHX
        PSHA
        STAB    0x0,SP
//   43     return w|=PowerOfTwoTab16[num];
        TFR     Y,D
        PSHD
        LDAA    0x2,SP
        LDAB    #0x2
        MUL
        TFR     D,Y
        PULD
        ORAB    PowerOfTwoTab16 + 1,Y
        ORAA    PowerOfTwoTab16,Y
        TFR     D,X
        TFR     X,Y
        TFR     X,D
        LEAS    0x1,SP
        PULX
        RTS
//   44 }
//   45 
//   46 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//   47 uint16 Utl_BitReset(uint16 w,uint8 num)
Utl_BitReset:
//   48 {
        PSHX
//   49     return w&=~(PowerOfTwoTab16[num]);
        PSHY
        LDAA    #0x2
        MUL
        TFR     D,Y
        LDD     PowerOfTwoTab16,Y
        COMA
        COMB
        ANDB    0x1,SP
        ANDA    0x0,SP
        TFR     D,X
        TFR     X,Y
        TFR     X,D
        LEAS    0x2,SP
        PULX
        RTS
//   50 }
//   51 
//   52 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//   53 uint16 Utl_BitToggle(uint16 w,uint8 num)
Utl_BitToggle:
//   54 {
        PSHX
        PSHA
        STAB    0x0,SP
//   55     return w^=PowerOfTwoTab16[num];
        TFR     Y,D
        PSHD
        LDAA    0x2,SP
        LDAB    #0x2
        MUL
        TFR     D,Y
        PULD
        EORB    PowerOfTwoTab16 + 1,Y
        EORA    PowerOfTwoTab16,Y
        TFR     D,X
        TFR     X,Y
        TFR     X,D
        LEAS    0x1,SP
        PULX
        RTS
//   56 }
//   57 
//   58 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//   59 uint16 Utl_BitGetHighest(uint16 w)
Utl_BitGetHighest:
//   60 {
        TFR     D,Y
//   61     w|=w>>1;
        PSHY
        TFR     Y,D
        LSRD
        ORAB    0x1,SP
        ORAA    0x0,SP
        TFR     D,Y
//   62     w|=w>>2;
        LEAS    0x2,SP
        PSHY
        TFR     Y,D
        LSRD
        LSRD
        ORAB    0x1,SP
        ORAA    0x0,SP
        TFR     D,Y
//   63     w|=w>>4;
        LEAS    0x2,SP
        PSHY
        TFR     Y,D
        LSRD
        LSRD
        LSRD
        LSRD
        ORAB    0x1,SP
        ORAA    0x0,SP
        TFR     D,Y
//   64     w|=w>>8;
        LEAS    0x2,SP
        PSHY
        TFR     Y,D
        TFR     A,B
        CLRA
        ORAB    0x1,SP
        ORAA    0x0,SP
        TFR     D,Y
//   65 
//   66     return w^(w>>1);
        LEAS    0x2,SP
        PSHY
        TFR     Y,D
        LSRD
        EORB    0x1,SP
        EORA    0x0,SP
        LEAS    0x2,SP
        RTS
//   67 }
//   68 
//   69 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//   70 uint16 Utl_BitGetLowest(uint16 w)
Utl_BitGetLowest:
//   71 {
        TFR     D,Y
//   72     return (~w+1) & w;
        TFR     Y,D
        COMA
        COMB
        ADDD    #0x1
        PSHD
        TFR     Y,D
        ANDB    0x1,SP
        ANDA    0x0,SP
        LEAS    0x2,SP
        RTS
//   73 }
//   74 
//   75 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//   76 uint16 Utl_BitSetLowest(uint16 w)
Utl_BitSetLowest:
//   77 {
        TFR     D,Y
//   78     return w | (w+1);
        PSHY
        LEAY    0x1,Y
        TFR     Y,D
        ORAB    0x1,SP
        ORAA    0x0,SP
        LEAS    0x2,SP
        RTS
//   79 }
//   80 
//   81 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//   82 uint16 Utl_BitResetLowest(uint16 w)
Utl_BitResetLowest:
//   83 {
        TFR     D,Y
//   84     return w & (w-1);
        PSHY
        LEAY    -0x1,Y
        TFR     Y,D
        ANDB    0x1,SP
        ANDA    0x0,SP
        LEAS    0x2,SP
        RTS
//   85 }
//   86 
//   87 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//   88 uint8 Utl_Log2(uint16 num)
Utl_Log2:
//   89 {
        PSHX
        PSHA
        TFR     D,Y
//   90     uint8 res=(uint8)0x00;
        CLR     0x0,SP
//   91     
//   92     while (num>>=1) {
??Utl_Log2_0:
        TFR     Y,D
        LSRD
        TFR     D,X
        TFR     X,Y
        CPX     #0x0
        BEQ     ??Utl_Log2_1
//   93         res++;
        LDAB    0x0,SP
        ADDB    #0x1
        STAB    0x0,SP
        BRA     ??Utl_Log2_0
//   94     }
//   95 
//   96     return res;
??Utl_Log2_1:
        LDAB    0x0,SP
        PULA
        PULX
        RTS
//   97 }
//   98 
//   99 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  100 Utl_EndianessType Utl_CheckEndianess(void)
Utl_CheckEndianess:
//  101 {
        PSHD
//  102     const uint16 foo=0xaa55U;
        LDD     #0xaa55
        STD     0x0,SP
//  103     uint8 *ptr=(uint8*)&foo;
        LEAY    0x0,SP
//  104     
//  105     if (0[ptr]==(uint8)0xaa) {
        LDAB    0x0,Y
        CMPB    #0xaa
        BNE     ??Utl_CheckEndianess_0
//  106         return UTL_BIG_ENDIAN;   
        LDAB    #0x0
        BRA     ??Utl_CheckEndianess_1
//  107     } else {
//  108         return UTL_LITTLE_ENDIAN;
??Utl_CheckEndianess_0:
        LDAB    #0x1
??Utl_CheckEndianess_1:
        PULY
        RTS
//  109     }
//  110 }
//  111 
//  112 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  113 void Utl_MemCopy(void * RESTRICT dst,void * RESTRICT src,SizeType len)
Utl_MemCopy:
//  114 {
        PSHX
        LEAS    -0x8,SP
        STY     0x4,SP
        STD     0x6,SP
//  115     uint8 *pd=(uint8*)dst;
        LDD     0x4,SP
        STD     0x0,SP
//  116     uint8 *ps=(uint8*)src;
        LDD     0x6,SP
        STD     0x2,SP
//  117 
//  118     ASSERT(dst!=(void*)NULL);
        LDD     0x4,SP
        BNE     ??Utl_MemCopy_0
        bgnd
//  119     ASSERT(pd>=ps+len || ps>=pd+len);
??Utl_MemCopy_0:
        LDD     0x2,SP
        ADDD    0xc,SP
        CPD     0x0,SP
        BLS     ??Utl_MemCopy_1
        LDD     0x0,SP
        ADDD    0xc,SP
        CPD     0x2,SP
        BLS     ??Utl_MemCopy_1
        bgnd
//  120     ASSERT(len!=(SizeType)0);
??Utl_MemCopy_1:
        LDD     0xc,SP
        BNE     ??Utl_MemCopy_2
        bgnd
//  121     
//  122     while (len--) {
??Utl_MemCopy_2:
        LDY     0xc,SP
        LEAX    -0x1,Y
        STX     0xc,SP
        CPY     #0x0
        BEQ     ??Utl_MemCopy_3
//  123         *pd++=*ps++;
        LDAB    [0x2,SP]
        STAB    [0x0,SP]
        LDD     0x2,SP
        ADDD    #0x1
        STD     0x2,SP
        LDD     0x0,SP
        ADDD    #0x1
        STD     0x0,SP
        BRA     ??Utl_MemCopy_2
//  124     }
//  125     
//  126 }
??Utl_MemCopy_3:
        LEAS    0x8,SP
        PULX
        RTS
//  127 
//  128 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  129 void Utl_MemSet(void *dest,uint8 fill_char,SizeType len)
Utl_MemSet:
//  130 {
        PSHX
        LEAS    -0x6,SP
        STY     0x2,SP
        STD     0x4,SP
//  131     uint8 *p=(uint8*)dest;
        LDD     0x2,SP
        STD     0x0,SP
//  132 
//  133     ASSERT(dest!=(void*)NULL);
        LDD     0x2,SP
        BNE     ??Utl_MemSet_0
        bgnd
//  134     
//  135     while (len--) {
??Utl_MemSet_0:
        LDY     0x4,SP
        LEAX    -0x1,Y
        STX     0x4,SP
        CPY     #0x0
        BEQ     ??Utl_MemSet_1
//  136         *p++=fill_char; 
        LDAB    0xa,SP
        STAB    [0x0,SP]
        LDD     0x0,SP
        ADDD    #0x1
        STD     0x0,SP
        BRA     ??Utl_MemSet_0
//  137     }
//  138 }
??Utl_MemSet_1:
        LEAS    0x6,SP
        PULX
        RTS
//  139 
//  140 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  141 void Utl_Randomize(uint16 seed)
Utl_Randomize:
//  142 {
        PSHX
        TFR     D,X
//  143     NextRandomNumber=(uint32)seed;
        TFR     X,Y
        CLRA
        CLRB
        STY     NextRandomNumber + 2
        STD     NextRandomNumber
//  144 }
        PULX
        RTS
//  145 
//  146 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  147 uint16 Utl_Random(void)
Utl_Random:
//  148 {
        PSHX
//  149     NextRandomNumber=NextRandomNumber * (uint32)0x41C64E6DUL + (uint32)0x3039UL;
        LDD     NextRandomNumber + 2
        PSHD
        LDD     NextRandomNumber
        PSHD
        LDD     #0x41c6
        LDY     #0x4e6d
        JSR     ??lmul
        LEAS    0x4,SP
        PSHY
        PSHD
        LDD     0x2,SP
        ADDD    #0x3039
        STD     NextRandomNumber + 2
        LDD     0x0,SP
        ADCB    #0x0
        ADCA    #0x0
        STD     NextRandomNumber
//  150     return (uint16)(NextRandomNumber/(uint32)0x10000UL) % (uint32)0x8000UL;
        LDD     NextRandomNumber
        LDX     #0x8000
        IDIV
        LEAS    0x4,SP
        PULX
        RTS
//  151 
//  152 }
//  153 
//  154 

        RSEG CODE:CODE:NOROOT(0)
//  155 SizeType Utl_StrLen(const uint8 *src)
Utl_StrLen:
//  156 {
        PSHX
        PSHD
//  157     SizeType len=(SizeType)0x0000;
        LDD     #0x0
        STD     0x0,SP
//  158 
//  159     while (*(src++)) {
??Utl_StrLen_0:
        TFR     Y,X
        LEAY    0x1,X
        TST     0x0,X
        BEQ     ??Utl_StrLen_1
//  160         len++;        
        LDD     0x0,SP
        ADDD    #0x1
        STD     0x0,SP
        BRA     ??Utl_StrLen_0
//  161     }
//  162     
//  163     return len;
??Utl_StrLen_1:
        LDD     0x0,SP
        PULY
        PULX
        RTS
//  164 }
//  165 
//  166 

        RSEG CODE:CODE:NOROOT(0)
//  167 void Utl_StrCat(uint8 * RESTRICT dst,const uint8 * RESTRICT  src)
Utl_StrCat:
//  168 {
        PSHX
        LEAS    -0x3,SP
        STD     0x1,SP
        TFR     Y,X
//  169     ASSERT(dst!=(void*)NULL);
        CPX     #0x0
        BNE     ??Utl_StrCat_0
        bgnd
//  170     
//  171     while (*(dst++))
??Utl_StrCat_0:
        TFR     X,Y
        LEAX    0x1,Y
        TST     0x0,Y
        BNE     ??Utl_StrCat_0
//  172         {}
//  173     --dst;
        LEAX    -0x1,X
//  174 
//  175     while (*(dst++)=*(src++))
??Utl_StrCat_1:
        LDAB    [0x1,SP]
        STAB    0x0,SP
        LDD     0x1,SP
        ADDD    #0x1
        STD     0x1,SP
        LDAB    0x0,SP
        STAB    0x0,X
        LEAX    0x1,X
        TST     0x0,SP
        BNE     ??Utl_StrCat_1
//  176         {}
//  177 }
        LEAS    0x3,SP
        PULX
        RTS
//  178 
//  179 

        RSEG CODE:CODE:NOROOT(0)
//  180 void Utl_StrCpy(uint8 * RESTRICT dst,const uint8 * RESTRICT  src)
Utl_StrCpy:
//  181 {
        PSHX
        LEAS    -0x3,SP
        STD     0x1,SP
        TFR     Y,X
//  182     ASSERT(dst!=(void*)NULL);
        CPX     #0x0
        BNE     ??Utl_StrCpy_0
        bgnd
//  183 
//  184     while (*(dst++)=*(src++))
??Utl_StrCpy_0:
        LDAB    [0x1,SP]
        STAB    0x0,SP
        LDD     0x1,SP
        ADDD    #0x1
        STD     0x1,SP
        LDAB    0x0,SP
        STAB    0x0,X
        LEAX    0x1,X
        TST     0x0,SP
        BNE     ??Utl_StrCpy_0
//  185         {}
//  186 }
        LEAS    0x3,SP
        PULX
        RTS
//  187 
//  188 
//  189 
//  190 #if 0
//  191 void Utl_StrNCpy(uint8 * RESTRICT dst,const uint8 * RESTRICT  src,SizeType maxlen)
//  192 {
//  193     ASSERT(dest!=(void*)NULL);
//  194     
//  195     while ((*(dst++)=*(src++)) && (maxlen--))
//  196         {}
//  197 }
//  198 #endif
//  199 
//  200 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  201 void Utl_StrRev(uint8 *str)
Utl_StrRev:
//  202 {
        PSHX
        LEAS    -0x7,SP
        STY     0x0,SP
//  203     SizeType idx;
//  204     SizeType dpos;
//  205     uint8 ch;
//  206 
//  207     ASSERT(str!=(void*)NULL);
        LDD     0x0,SP
        BNE     ??Utl_StrRev_0
        bgnd
//  208     
//  209     for (idx=(SizeType)0,dpos=Utl_StrLen(str)-1;dpos>idx;idx++,dpos--) {
??Utl_StrRev_0:
        LDD     #0x0
        STD     0x2,SP
        LDY     0x0,SP
        JSR     Utl_StrLen
        ADDD    #0xffff
        STD     0x4,SP
??Utl_StrRev_1:
        LDD     0x2,SP
        CPD     0x4,SP
        BCC     ??Utl_StrRev_2
//  210         ch=dpos[str];
        LDD     0x0,SP
        ADDD    0x4,SP
        TFR     D,Y
        LDAB    0x0,Y
        STAB    0x6,SP
//  211         dpos[str]=idx[str];
        LDD     0x0,SP
        ADDD    0x2,SP
        TFR     D,X
        LDD     0x0,SP
        ADDD    0x4,SP
        TFR     D,Y
        LDAB    0x0,X
        STAB    0x0,Y
//  212         idx[str]=ch;
        LDD     0x0,SP
        ADDD    0x2,SP
        TFR     D,Y
        LDAB    0x6,SP
        STAB    0x0,Y
//  213     } 
        LDD     0x2,SP
        ADDD    #0x1
        STD     0x2,SP
        LDD     0x4,SP
        ADDD    #0xffff
        STD     0x4,SP
        BRA     ??Utl_StrRev_1
//  214 }
??Utl_StrRev_2:
        LEAS    0x7,SP
        PULX
        RTS
//  215 
//  216 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  217 const uint8 * Utl_StrChr(const uint8 * str,uint8 ch)
Utl_StrChr:
//  218 {
        PSHX
        PSHA
        STAB    0x0,SP
        TFR     Y,X
//  219     ASSERT(str!=(void*)NULL);
        CPX     #0x0
        BNE     ??Utl_StrChr_0
        bgnd
//  220     
//  221     while (*str) {
??Utl_StrChr_0:
        TST     0x0,X
        BEQ     ??Utl_StrChr_1
//  222         if (*(str++)==ch) {
        TFR     X,Y
        LEAX    0x1,Y
        LDAB    0x0,Y
        CMPB    0x0,SP
        BNE     ??Utl_StrChr_0
//  223             return str;   
        TFR     X,Y
        BRA     ??Utl_StrChr_2
//  224         }
//  225     }
//  226 
//  227     return (const uint8 *)NULL;
??Utl_StrChr_1:
        LDY     #0x0
??Utl_StrChr_2:
        PULA
        PULX
        RTS
//  228 }
//  229 
//  230 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  231 void Utl_Itoa(uint32 value,uint8 base,uint8 * buf)
Utl_Itoa:
//  232 {
        PSHX
        LEAS    -0x8,SP
        STAB    0x2,SP
        TFR     Y,X
//  233     uint32 mod;
//  234     uint8 pos=(uint8)0x00,swap_pos=(uint8)0x00;
        CLR     0x0,SP
        CLR     0x1,SP
//  235     uint8 ch;
//  236     
//  237     ASSERT(buf!=(void*)NULL);    
        CPX     #0x0
        BNE     ??Utl_Itoa_0
        bgnd
//  238     
//  239     if (((sint32)value)<0L && base==(uint8)10) {
??Utl_Itoa_0:
        TST     0xc,SP
        BPL     ??Utl_Itoa_1
        LDAB    0x2,SP
        CMPB    #0xa
        BNE     ??Utl_Itoa_1
//  240         value=(uint32)((sint32)value*-1L);
        LDD     0xe,SP
        PSHD
        LDD     0xe,SP
        PSHD
        LDD     #0xffff
        LDY     #0xffff
        JSR     ??lmul
        STY     0x12,SP
        STD     0x10,SP
//  241         buf[0]='-';
        LDAB    #0x2d
        STAB    0x0,X
//  242         swap_pos=1;
        LDAB    #0x1
        STAB    0x5,SP
//  243         pos=1;
        LDAB    #0x1
        STAB    0x4,SP
        LEAS    0x4,SP
//  244     }
//  245 
//  246     if (value==0L) {
??Utl_Itoa_1:
        LDD     0xc,SP
        BNE     ??Utl_Itoa_2
        LDD     0xe,SP
        BNE     ??Utl_Itoa_2
//  247         buf[pos++]='0';
        LDAB    0x0,SP
        LDAA    #0x30
        STAA    B,X
        LDAB    0x0,SP
        ADDB    #0x1
        STAB    0x0,SP
//  248     }
//  249     
//  250     while (value) {
??Utl_Itoa_2:
        LDD     0xe,SP
        BNE     ??Utl_Itoa_3
        LDD     0xc,SP
        BEQ     ??Utl_Itoa_4
//  251         mod=value%base;
??Utl_Itoa_3:
        LDD     0xe,SP
        PSHD
        LDD     0xe,SP
        PSHD
        LDAB    0x6,SP
        EXG     B,Y
        CLRA
        CLRB
        JSR     ??lumod
        STY     0xa,SP
        STD     0x8,SP
//  252         if (mod<10) {
        LDD     0xa,SP
        SUBD    #0xa
        LDD     0x8,SP
        SBCB    #0x0
        SBCA    #0x0
        LEAS    0x4,SP
        BCC     ??Utl_Itoa_5
//  253             buf[pos++]='0'+mod;
        LDAB    0x7,SP
        ADDB    #0x30
        LDAA    0x0,SP
        STAB    A,X
        LDAB    0x0,SP
        ADDB    #0x1
        STAB    0x0,SP
        BRA     ??Utl_Itoa_6
//  254         } else {
//  255             buf[pos++]='A'+mod-(uint8)10;
??Utl_Itoa_5:
        LDAB    0x7,SP
        ADDB    #0x37
        LDAA    0x0,SP
        STAB    A,X
        LDAB    0x0,SP
        ADDB    #0x1
        STAB    0x0,SP
//  256         }
//  257         value/=base;
??Utl_Itoa_6:
        LDD     0xe,SP
        PSHD
        LDD     0xe,SP
        PSHD
        LDAB    0x6,SP
        EXG     B,Y
        CLRA
        CLRB
        JSR     ??ludiv
        STY     0x12,SP
        STD     0x10,SP
        LEAS    0x4,SP
        BRA     ??Utl_Itoa_2
//  258     }
//  259 
//  260     buf[pos--]='\0';
??Utl_Itoa_4:
        LDAB    0x0,SP
        CLR     B,X
        LDAB    0x0,SP
        ADDB    #0xff
        STAB    0x0,SP
//  261 
//  262     while (pos>swap_pos) {
??Utl_Itoa_7:
        LDAB    0x1,SP
        CMPB    0x0,SP
        BCC     ??Utl_Itoa_8
//  263         ch=buf[swap_pos];
        LDAB    0x1,SP
        LEAY    B,X
        LDAB    0x0,Y
        STAB    0x3,SP
//  264         buf[swap_pos]=buf[pos];
        LDAB    0x0,SP
        LEAY    B,X
        LDAB    0x1,SP
        LDAA    0x0,Y
        STAA    B,X
//  265             buf[pos]=ch;
        LDAB    0x0,SP
        LDAA    0x3,SP
        STAA    B,X
//  266         swap_pos++;
        LDAB    0x1,SP
        ADDB    #0x1
        STAB    0x1,SP
//  267         pos--;
        LDAB    0x0,SP
        ADDB    #0xff
        STAB    0x0,SP
        BRA     ??Utl_Itoa_7
//  268     }
//  269 }
??Utl_Itoa_8:
        LEAS    0x8,SP
        PULX
        RTS
//  270 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  271 void const * Utl_BinSearch(void const * key,void const * base,uint16 num_elems,uint16 elem_size,Utl_CompareFuncType compare_func)
Utl_BinSearch:
//  272 {    
        PSHX
        LEAS    -0xd,SP
        STY     0x9,SP
        STD     0xb,SP
        LDX     0x15,SP
//  273     uint16 mid;
//  274     sint16 left,right;
//  275     uint8 *cmp_key;
//  276     sint8 res;
//  277 
//  278     left=(sint16)0x0000;
        LDD     #0x0
        STD     0x3,SP
//  279     right=(sint16)(num_elems-1);
        LDD     0x11,SP
        ADDD    #0xffff
        STD     0x5,SP
//  280     
//  281     do {
//  282         mid=(uint16)(left+right)>>1;
??Utl_BinSearch_0:
        LDD     0x3,SP
        ADDD    0x5,SP
        LSRD
        STD     0x1,SP
//  283         cmp_key=(uint8*)((uint8*)base+(mid*elem_size));
        LDY     0x1,SP
        LDD     0x13,SP
        EMUL
        ADDD    0xb,SP
        STD     0x7,SP
//  284         res=compare_func(key,cmp_key);
        LDD     0x7,SP
        LDY     0x9,SP
        JSR     0x0,X
        STAB    0x0,SP
//  285         if (res==(sint16)0) {
        TST     0x0,SP
        BNE     ??Utl_BinSearch_1
//  286             return cmp_key;   
        LDY     0x7,SP
        BRA     ??Utl_BinSearch_2
//  287         } else if (res<(uint8)0) {
??Utl_BinSearch_1:
        TST     0x0,SP
        BPL     ??Utl_BinSearch_3
//  288             right=mid-1;            
        LDD     0x1,SP
        ADDD    #0xffff
        STD     0x5,SP
        BRA     ??Utl_BinSearch_4
//  289         } else {
//  290             left=mid+1;            
??Utl_BinSearch_3:
        LDD     0x1,SP
        ADDD    #0x1
        STD     0x3,SP
//  291         } 
//  292     } while (left<=right);
??Utl_BinSearch_4:
        LDD     0x5,SP
        CPD     0x3,SP
        BGE     ??Utl_BinSearch_0
//  293 
//  294     return (void const *)NULL;
        LDY     #0x0
??Utl_BinSearch_2:
        LEAS    0xd,SP
        PULX
        RTS
//  295 }
//  296 
//  297 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  298 boolean Utl_FloatsAreNearlyEqual(float lhs,float rhs,sint32 max_difference)
Utl_FloatsAreNearlyEqual:
//  299 {
        LEAS    -0x10,SP
        STY     0xe,SP
        STD     0xc,SP
//  300     sint32 lhs_int=*(sint32*)&lhs;
        LDD     0xe,SP
        STD     0x2,SP
        LDD     0xc,SP
        STD     0x0,SP
//  301     sint32 rhs_int=*(sint32*)&rhs;
        LDD     0x14,SP
        STD     0x6,SP
        LDD     0x12,SP
        STD     0x4,SP
//  302     sint32 int_difference;
//  303     
//  304     if (lhs_int<(sint32)0) {
        TST     0x0,SP
        BPL     ??Utl_FloatsAreNearlyEqual_0
//  305         lhs_int=(sint32)(0x80000000-lhs_int);
        LDD     #0x0
        SUBD    0x2,SP
        STD     0x2,SP
        LDD     #0x8000
        SBCB    0x1,SP
        SBCA    0x0,SP
        STD     0x0,SP
//  306     }
//  307     
//  308     if (rhs_int<(sint32)0) {
??Utl_FloatsAreNearlyEqual_0:
        TST     0x4,SP
        BPL     ??Utl_FloatsAreNearlyEqual_1
//  309         rhs_int=(sint32)(0x80000000-rhs_int);
        LDD     #0x0
        SUBD    0x6,SP
        STD     0x6,SP
        LDD     #0x8000
        SBCB    0x5,SP
        SBCA    0x4,SP
        STD     0x4,SP
//  310     }    
//  311 
//  312     int_difference=ABS(lhs_int-rhs_int);
??Utl_FloatsAreNearlyEqual_1:
        LDD     0x2,SP
        SUBD    0x6,SP
        PSHD
        LDD     0x2,SP
        SBCB    0x7,SP
        SBCA    0x6,SP
        TSTA
        LEAS    0x2,SP
        BPL     ??Utl_FloatsAreNearlyEqual_2
        LDD     0x2,SP
        SUBD    0x6,SP
        PSHD
        LDD     0x2,SP
        SBCB    0x7,SP
        SBCA    0x6,SP
        PSHD
        LDD     #0xffff
        LDY     #0xffff
        JSR     ??lmul
        STY     0xe,SP
        STD     0xc,SP
        LEAS    0x4,SP
        BRA     ??Utl_FloatsAreNearlyEqual_3
??Utl_FloatsAreNearlyEqual_2:
        LDD     0x2,SP
        SUBD    0x6,SP
        STD     0xa,SP
        LDD     0x0,SP
        SBCB    0x5,SP
        SBCA    0x4,SP
        STD     0x8,SP
//  313 
//  314     return ((int_difference<=max_difference) ? TRUE : FALSE);
??Utl_FloatsAreNearlyEqual_3:
        LDD     0x18,SP
        SUBD    0xa,SP
        LDD     0x16,SP
        SBCB    0x9,SP
        SBCA    0x8,SP
        BLT     ??Utl_FloatsAreNearlyEqual_4
        LDAB    #0x1
        BRA     ??Utl_FloatsAreNearlyEqual_5
??Utl_FloatsAreNearlyEqual_4:
        LDAB    #0x0
??Utl_FloatsAreNearlyEqual_5:
        LEAS    0x10,SP
        RTS
//  315 }
//  316 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  317 boolean Utl_IsNull(void *Ptr)
Utl_IsNull:
//  318 {
//  319     return (Ptr==(void*)NULL) ? TRUE : FALSE;
        CPY     #0x0
        BNE     ??Utl_IsNull_0
        LDAB    #0x1
        RTS
??Utl_IsNull_0:
        LDAB    #0x0
        RTS
//  320 }
//  321 
//  322 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  323 uint16 Utl_Swap16(uint16 *w)
Utl_Swap16:
//  324 {
//  325     return MAKEWORD(LOBYTE(*w),HIBYTE(*w));
        LDAA    0x1,Y
        LDAB    #0x0
        ORAB    0x0,Y
        RTS
//  326 }
//  327 
//  328 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//  329 uint32 Utl_Swap32(uint32 *dw)
Utl_Swap32:
//  330 {
        PSHX
//  331     return MAKEDWORD(MAKEWORD(LOBYTE(LOWORD(*dw)),HIBYTE(LOWORD(*dw))),MAKEWORD(LOBYTE(HIWORD(*dw)),HIBYTE(HIWORD(*dw))));
        LDAA    0x3,Y
        LDAB    #0x0
        ORAB    0x2,Y
        LDX     #0x0
        PSHX
        PSHD
        LDAA    0x1,Y
        LDAB    #0x0
        ORAB    0x0,Y
        PSHD
        CLRB
        CLRA
        PULY
        JSR     ??lior
        LEAS    0x4,SP
        PULX
        RTS
//  332 }

        RSEG DATA16_ID:CONST:NOROOT(0)
`?<Initializer for NextRandomNumber>`:
        DC32 1

        RSEG DATA16_ID:CONST:NOROOT(0)
`?*?DATA16_ID`:

        RSEG INITTAB:CODE:ROOT(0)
?init?tab?DATA16_I:
        DC16    sfe(DATA16_I) - sfb(DATA16_I), sfb(DATA16_I), sfb(DATA16_ID)

        END
// 
// 1 249 bytes in segment CODE
//    32 bytes in segment DATA16_C
//     4 bytes in segment DATA16_I
//     4 bytes in segment DATA16_ID
//     6 bytes in segment INITTAB
// 
// 1 249 bytes of CODE  memory (+ 6 bytes shared)
//    36 bytes of CONST memory
//     4 bytes of DATA  memory
//
//Errors: none
//Warnings: 1
