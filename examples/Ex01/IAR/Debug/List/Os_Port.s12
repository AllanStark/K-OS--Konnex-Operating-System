//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR HCS12 C/C++ Compiler V3.11A/W32                 17/Mar/2010  10:33:53 /
// Copyright 1997-2006 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Source file  =  C:\projekte\csProjects\k-os\src\Os_Port.c              /
//    Command line =  C:\projekte\csProjects\k-os\src\Os_Port.c              /
//                    --preprocess=l C:\projekte\csProjects\k-os\examples\Ex /
//                    01\IAR\Debug\List\ -lC C:\projekte\csProjects\k-os\exa /
//                    mples\Ex01\IAR\Debug\List\ -lB                         /
//                    C:\projekte\csProjects\k-os\examples\Ex01\IAR\Debug\Li /
//                    st\ --code_model=normal --double=32 -o                 /
//                    C:\projekte\csProjects\k-os\examples\Ex01\IAR\Debug\Ob /
//                    j\ --require_prototypes -e -z2 --no_cse --no_unroll    /
//                    --no_inline --no_code_motion --no_tbaa                 /
//                    --no_cross_call --debug "-D_DLIB_CONFIG_FILE=C:\Progra /
//                    mme\IAR Systems\Embedded Workbench Evaluation          /
//                    4.0\HCS12\LIB\DLIB\dlhcs12nfn.h" --segment             /
//                    __data8=DATA8 --segment __data16=DATA16 --segment      /
//                    __banked=BANKED_CODE --segment __non_banked=CODE       /
//                    --segment __intvec=INTVEC --segment __difunct=DIFUNCT  /
//                    --segment __cstack=CSTACK --segment __inittab=INITTAB  /
//                    -I C:\projekte\csProjects\k-os\inc\ -I                 /
//                    C:\projekte\csProjects\common\inc\ -I                  /
//                    C:\projekte\csProjects\common\ -I                      /
//                    C:\projekte\csProjects\common\InstallISR\ -I           /
//                    C:\projekte\csProjects\k-os\examples\Ex01\ -I          /
//                    C:\projekte\csProjects\common\drivers\include\cpu12\   /
//                    -I "C:\Programme\IAR Systems\Embedded Workbench        /
//                    Evaluation 4.0\HCS12\INC\" -I "C:\Programme\IAR        /
//                    Systems\Embedded Workbench Evaluation                  /
//                    4.0\HCS12\INC\DLIB\"                                   /
//    List file    =  C:\projekte\csProjects\k-os\examples\Ex01\IAR\Debug\Li /
//                    st\Os_Port.s12                                         /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME Os_Port

        RSEG CSTACK:DATA:REORDER:NOROOT(0)

        PUBLIC OSSystemTimerVector_Handler
        PUBLIC OS_TOS_ISR
        PUBLIC OsPortGetTimestamp
        PUBLIC OsPortInit
        PUBLIC OsPortTaskStackInit

        EXTERN OS_TCB
        EXTERN ISR_Stk
        EXTERN IncrementCounter
        EXTERN OsExec_StartHighestReadyTask

// C:\projekte\csProjects\k-os\src\Os_Port.c
//    1 /*
//    2  * k_os (Konnex Operating-System based on the OSEK/VDX-Standard).
//    3  *
//    4  * (C) 2007-2009 by Christoph Schueler <chris@konnex-tools.de>
//    5  *
//    6  * All Rights Reserved
//    7  *
//    8  * This program is free software; you can redistribute it and/or modify
//    9  * it under the terms of the GNU General Public License as published by
//   10  * the Free Software Foundation; either version 2 of the License, or
//   11  * (at your option) any later version.
//   12  *
//   13  * This program is distributed in the hope that it will be useful,
//   14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
//   15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   16  * GNU General Public License for more details.
//   17  *
//   18  * You should have received a copy of the GNU General Public License along
//   19  * with this program; if not, write to the Free Software Foundation, Inc.,
//   20  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
//   21  *
//   22  */
//   23 
//   24 #include "Os_Port.h"
//   25 
//   26 #define TICKS_PER_MS        ((TickType)1000)
//   27 

        RSEG DATA16_C:CONST:REORDER:NOROOT(0)
//   28 const SizeType OS_TOS_ISR=(SizeType)((const uint8*)&ISR_Stk+ISR_STACK_SIZE);
OS_TOS_ISR:
        DC16 ISR_Stk + 32
//   29 
//   30 #if 0
//   31 #define OS_TOS_ISR  ((uint16)((uint8*)&ISR_Stk+ISR_STACK_SIZE))
//   32 #endif
//   33 
//   34 

        RSEG DATA16_C:CONST:REORDER:NOROOT(0)
//   35 static const S12Ect_ConfigType Cfg={BASE_ADDR_ECT};
Cfg:
        DC16 64
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
//   36 
//   37 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//   38 uint8* OsPortTaskStackInit(TaskType TaskID,TaskFunctionType *TaskFunc,uint8 *sp,boolean Reschedule)
OsPortTaskStackInit:
//   39 {
        PSHX
        LEAS    -0x4,SP
        STAB    0x0,SP
        STY     0x2,SP
        STAA    0x1,SP
        LDX     0x8,SP
//   40     /* Return-Adresse / for  E_MISSING_END  */
//   41 #if 0   
//   42     *sp--=LOBYTE((uint16)(uint8*)OsExec_TaskReturnGuard);  /* StackGuardFunction */
//   43     *sp--=HIBYTE((uint16)(uint8*)OsExec_TaskReturnGuard);     
//   44 #endif  
//   45         
//   46     *sp--=LOBYTE((SizeType)*TaskFunc);
        LDY     0x2,SP
        LDAB    0x1,Y
        STAB    0x0,X
        LEAX    -0x1,X
//   47     *sp--=HIBYTE((SizeType)*TaskFunc);
        LDY     0x2,SP
        LDAB    0x0,Y
        STAB    0x0,X
        LEAX    -0x1,X
//   48     *sp--=((uint8)0xff);     /*  Y/Lo  */
        LDAB    #0xff
        STAB    0x0,X
        LEAX    -0x1,X
//   49     *sp--=((uint8)0xee);     /*  Y/Hi  */
        LDAB    #0xee
        STAB    0x0,X
        LEAX    -0x1,X
//   50     *sp--=((uint8)0xdd);     /*  X/Lo  */
        LDAB    #0xdd
        STAB    0x0,X
        LEAX    -0x1,X
//   51     *sp--=((uint8)0xcc);     /*  X/Hi  */
        LDAB    #0xcc
        STAB    0x0,X
        LEAX    -0x1,X
//   52     *sp--=((uint8)0xaa);     /*  AccA  */
        LDAB    #0xaa
        STAB    0x0,X
        LEAX    -0x1,X
//   53     *sp--=((uint8)0xbb);     /*  AccB  */
        LDAB    #0xbb
        STAB    0x0,X
        LEAX    -0x1,X
//   54     *sp--=((uint8)0xc0);     /*  CCR/Interrupts enabled.     (Parameter: XIRQ-Enable)  */
        LDAB    #0xc0
        STAB    0x0,X
        LEAX    -0x1,X
//   55     ++sp;
        LEAX    0x1,X
//   56         
//   57     if (Reschedule) {
        TST     0x1,SP
        BEQ     ??OsPortTaskStackInit_0
//   58         OS_TCB[TaskID].Stackpointer=sp;
        LDAA    0x0,SP
        LDAB    #0x7
        MUL
        TFR     D,Y
        STX     OS_TCB,Y
//   59         OsExec_StartHighestReadyTask();
        JSR     OsExec_StartHighestReadyTask
//   60     }
//   61 
//   62     return sp;
??OsPortTaskStackInit_0:
        TFR     X,Y
        LEAS    0x4,SP
        PULX
        RTS
//   63 }
//   64 
//   65 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//   66 void OsPortInit(void)
OsPortInit:
//   67 {
//   68         BYTE_REG(Cfg.BaseAddr,TSCR1)=(uint8)0x00;
        LDY     Cfg
        CLR     0x6,Y
//   69         BYTE_REG(Cfg.BaseAddr,TIOS)=IOS0;
        LDY     Cfg
        LDAB    #0x1
        STAB    0x0,Y
//   70         BYTE_REG(Cfg.BaseAddr,TCTL1)=(uint8)0x00;
        LDY     Cfg
        CLR     0x8,Y
//   71         BYTE_REG(Cfg.BaseAddr,TCTL2)=(uint8)0x00;
        LDY     Cfg
        CLR     0x9,Y
//   72         BYTE_REG(Cfg.BaseAddr,TSCR2)=/*TOI|*/PR0|PR1;
        LDY     Cfg
        LDAB    #0x3
        STAB    0xd,Y
//   73         BYTE_REG(Cfg.BaseAddr,TFLG1)=(uint8)0xFF;
        LDY     Cfg
        LDAB    #0xff
        STAB    0xe,Y
//   74         BYTE_REG(Cfg.BaseAddr,TSCR1)=TEN|TSFRZ/*|TFFCA*/;
        LDY     Cfg
        LDAB    #0xa0
        STAB    0x6,Y
//   75         BYTE_REG(Cfg.BaseAddr,MCCTL)=MCZI|MODMC|MCEN|MCPR1;
        LDY     Cfg
        LDAB    #0xc6
        STAB    0x26,Y
//   76         WORD_REG(Cfg.BaseAddr,MCCNT)=TICKS_PER_MS/*-1*/;
        LDY     Cfg
        LDD     #0x3e8
        STD     0x36,Y
//   77         BYTE_REG(Cfg.BaseAddr,MCCTL)|=FLMC;
        LDY     Cfg
        LDAB    #0x8
        ORAB    0x26,Y
        LDY     Cfg
        STAB    0x26,Y
//   78 }
        RTS
//   79 
//   80 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//   81 uint32 OsPortGetTimestamp(void)
OsPortGetTimestamp:
//   82 {
//   83     return TCNT;   
        LDD     #0x0
        LDY     #0x4
        RTS
//   84 }
//   85 
//   86 /*
//   87  * todo: Wird vom System-Generator erzeugt.
//   88  *	 Greift seinerseit auf Makros zurück, z.B.:
//   89  *	 'HC12_ECT_ACKNOWLEDGE_MDCU_INTERRUPT()',
//   90  *	 'S12_ECT_ACKNOWLEDGE_TC3_INTERRUPT()',
//   91  *	 Der Name des Timers sollte (muss) in das
//   92  *	 Makro eingearbeitet werden!!!
//   93  */
//   94 #define OS_ACKNOWLEDGE_xxxTIMER_INTERRUPT()    BYTE_REG(Cfg.BaseAddr,MCFLG)=MCZF
//   95 

        RSEG CODE:CODE:REORDER:NOROOT(0)
//   96 ISR(OSSystemTimerVector)
OSSystemTimerVector_Handler:
//   97 {
//   98     BYTE_REG(Cfg.BaseAddr,MCFLG)=MCZF;
        LDY     Cfg
        LDAB    #0x80
        STAB    0x27,Y
//   99     (void)IncrementCounter(SystemCounter);
        LDAB    #0x0
        JMP     IncrementCounter
//  100 }

        END
//  101 
// 
// 190 bytes in segment CODE
//  23 bytes in segment DATA16_C
// 
// 190 bytes of CODE  memory
//  23 bytes of CONST memory
//
//Errors: none
//Warnings: 1
